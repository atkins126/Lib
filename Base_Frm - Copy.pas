unit Base_Frm;

{-------------------------------------------------------------------------------
  NOTES:

  1. We only allow executables to run from C: drive. This is checke when an
     application is launched. In order to be able to debug apps, add this
     environment variable in Tools\Options\Environment Variables EXECUTABLES.
     Set the value to: C:\Data\Delphi\Projects\ProjectsXE3\

  3. Create the relevant application folder name in which the binary file will
     be generated by the compiler.

  4. Now set the output directory (Project\Options\Output Directory) for your
     executable to: $(EXECUTABLES)\<Bin Folder Name> where 'Bin Folder Name'
     represents the folder where you want your executables to be generated. This
     will generate the application executable on the C: drive.

     ShowMessage( (Sender as TAction).ActionComponent.Name );
-------------------------------------------------------------------------------}

interface

uses
  Winapi.Windows, Vcl.Forms, Winapi.Messages, System.SysUtils, System.Variants,
  System.IOUtils, System.Classes, Vcl.Graphics, Vcl.Controls, Vcl.Dialogs,
  Vcl.ImgList, Vcl.ActnList, System.Actions, System.Win.Registry, System.IniFiles,
  Vcl.ExtCtrls, Vcl.AppEvnts, Winapi.ShlObj, Data.DB, DataSnap.DBClient,
  Vcl.Clipbrd, Vcl.ComCtrls, System.ImageList, Vcl.Menus,

  VBCommonValues,

  // JEDI
//  JclSysInfo,

  // DevExpress
  dxRibbonForm, cxContainer, cxEdit, cxClasses, cxStyles, cxCalendar, cxFormats,
  cxGraphics, cxControls, cxLabel, cxCheckBox, cxDBEdit, dxSkinsDefaultPainters,
  cxGridTableView, cxGridCustomView, cxGridCustomTableView, cxListView,
  cxImageList, dxLayoutLookAndFeels, cxLookAndFeels;

//  cxGraphics, cxStyles,
//  cxClasses, cxContainer, cxEdit, cxLookAndFeels, cxDBLookupComboBox,
//  dxBar, dxSkinsForm;

type
//  TShellResource = record
//    ShellResourceFileFolder: string;
//    RootFolder: string;
//    SkinName: string;
//    SOAPServerName: string;
//    ConnectionDefinitionFileLocation: string;
//    ConnectionDefinitionFileName: string;
//    ApplicationFolder: string;
//    ExcelFolder: String;
//    PDFFolder: String;
//  end;

  TBaseFrm = class(TdxRibbonForm)
    styRepository: TcxStyleRepository;
    styEditControllerReadOnly: TcxEditStyleController;
    actList: TActionList;
    lafLayoutList: TdxLayoutLookAndFeelList;
    lafCustomSkin: TdxLayoutSkinLookAndFeel;
    img16: TcxImageList;
    img32: TcxImageList;
    // Custom methods
    procedure SendWinMsg(DataStructure: TCopyDataStruct);
    procedure SendString(S: string);
    function ItemExists(SQLQuery: string): string;
    procedure SetComponentProperties;
    procedure ProcessRegistrySkin;
    procedure VerifyFolderStructure(RootDataFolder: string);
    function GetUserData: TUserData;
//    function GetShellResource: TShellResource;
    function LoadSkin(SkinFileName, SkinName: string): string;
    procedure CopyCellValue(AView: TcxCustomGridView);
    function UpdateHistoryList(ListView: TcxListView; Item, ItemDesc: string): TcxListView;
    procedure FormShow(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure DoCopyCellContent(Sender: TObject);
  private
    { Private declarations }
  public
    { Public declarations }
//    FShellResource: TShellResource;
    FMainCaption: string;
    FSLGen: TStringList;
    FQueryIniFile: TIniFile;
    FServerError: Boolean;
    FBeepFreq: Integer;
    FBeepDuration: Integer;
    FRootDataFolder: string;
    FAppDataFolder: string;
    FSwitchPrefix: TSysCharSet;
    FAppTitle: string;
    FSLRight: TStringList;
    FUserRight: TUserRightSet;
    FCallingFromShell: Boolean;
    FView: TcxCustomGridView;
    FAction: TActionArray;
    FUserData: TUserData;
    FCaptionTextColour: TColor;

//    property ShellResource: TShellResource read FShellResource write FShellResource;
    property MainCaption: string read FMainCaption write FMainCaption;
    property SLGenGen: TStringList read FSLGen write FSLGen;
    property QueryIniFile: TIniFile read FQueryIniFile write FQueryIniFile;
    property ServerError: Boolean read FServerError write FServerError;
    property BeepFreq: Integer read FBeepFreq write FBeepFreq;
    property BeepDuration: Integer read FBeepDuration write FBeepDuration;
//    property RootDataFolder: string read FRootDataFolder write FRootDataFolder;
//    property AppDataFolder: string read FAppDataFolder write FAppDataFolder;
    // Used for determining application launch parameters.
    property SwitchPrefix: TSysCharSet read FSwitchPrefix write FSwitchPrefix;
    property AppTitle: string read FAppTitle write FAppTitle;
    property SLRight: TStringList read FSLRight write FSLRight;
    property UserRight: TUserRightSet read FUserRight write FUserRight;
    property CallingFromShell: Boolean read FCallingFromShell write FCallingFromShell;
    property View: TcxCustomGridView read FView write FView;
    property Action: TActionArray read FAction write FAction;
    property UserData: TUserData read FUserData write FUserData;
    property CaptionTextColour: TColor read FCaptionTextColour write FCaptionTextColour;
  end;

var
  BaseFrm: TBaseFrm;

implementation

{$R *.dfm}

uses
  RUtils;

{ TBaseFrm }

procedure TBaseFrm.FormCreate(Sender: TObject);
begin
// Note to developer
// It is absolutely imperative that this event is invoked!! Even if there is
// no code.

  Self.Scaled := False;
  Self.ScaleBy(Screen.PixelsPerInch, 96);

  // Setup system date parameters
  System.SysUtils.FormatSettings.DateSeparator := '/';
  System.SysUtils.FormatSettings.ShortDateFormat := 'dd/MM/yyyy';
  System.SysUtils.FormatSettings.LongDateFormat := 'dd MMMM yyyy';
  cxFormatController.BeginUpdate;
  cxFormatController.UseDelphiDateTimeFormats := True;
  cxFormatController.EndUpdate;
  cxFormatController.GetFormats;
  cxFormatController.NotifyListeners;
//  FCaptionTextColour := RootLookAndFeel.SkinPainter.DefaultSelectionColor;
end;

procedure TBaseFrm.FormShow(Sender: TObject);
begin
//  styEditControllerReadOnly.Style.TextColor := RootLookAndFeel.SkinPainter.DefaultSelectionColor;
end;

function TBaseFrm.LoadSkin(SkinFileName, SkinName: string): string;
begin
  Result := DEFAULT_SKIN_NAME;
  if dxSkinsUserSkinLoadFromFile(SkinFileName, SkinName) then
    Result := SkinName
end;

procedure TBaseFrm.ProcessRegistrySkin;
var
  RegKey: TRegistry;
begin
  RegKey := TRegistry.Create(KEY_ALL_ACCESS or KEY_WRITE or KEY_WOW64_64KEY);
  try
    RegKey.RootKey := HKEY_CURRENT_USER;
    RegKey.OpenKey(KEY_USER_PREFERENCES, True);

    if not RegKey.ValueExists('Skin Name') then
      RegKey.WriteString('Skin Name', DEFAULT_SKIN_NAME);

    if Length(Trim(RegKey.ReadString('Skin Name'))) = 0 then
      RegKey.WriteString('Skin Name', DEFAULT_SKIN_NAME);

    RegKey.CloseKey;

    // ------------------------------------------------------------------------------
    RegKey.OpenKey(KEY_RESOURCE, True);
    // Check for the esitence of the required keys and values and create and
    // populate them with default values if they don't.
    if not RegKey.ValueExists('Skin Resoucre File Location') then
      RegKey.WriteString('Skin Resoucre File Location', 'C:\RC Data\');

    if not RegKey.ValueExists('Skin Resoucre File Name') then
      RegKey.WriteString('Skin Resoucre File Name', 'AllSKins.skinres');

    // Create the common resource folder if it does not exist.
    TDirectory.CreateDirectory
      (RegKey.ReadString('Skin Resoucre File Location'));
    RegKey.CloseKey;
  finally
    RegKey.Free;
  end;
end;

procedure TBaseFrm.SetComponentProperties;
var
  I: Integer;
begin
  for I := 0 to ComponentCount - 1 do
  begin
    // Minimise flickering of DX controls
    if Components[I] is TcxControl then
      (Components[I] as TcxControl).DoubleBuffered := True;

    if (Components[I] is TcxLabel) then
    begin
      (Components[I] as TcxLabel).Properties.Transparent := True;
      (Components[I] as TcxLabel).Style.TransparentBorder := False;
    end;

    if (Components[I] is TcxCheckBox) then
      (Components[I] as TcxCheckBox).Transparent := True;

    if (Components[I] is TcxDBCheckBox) then
      (Components[I] as TcxDBCheckBox).Transparent := True;

    // Set navigator width to look proportional
    // if (Components[I] is TcxNavigator) then
    // (Components[I] as TcxNavigator).Width :=
    // (Components[I] as TcxNavigator).Height *
    // (Components[I] as TcxNavigator).Buttons.ButtonCount;
    //
    // if (Components[I] is TcxDBNavigator) then
    // (Components[I] as TcxDBNavigator).Width :=
    // (Components[I] as TcxDBNavigator).Height *
    // (Components[I] as TcxDBNavigator).Buttons.ButtonCount;
  end;
end;

procedure TBaseFrm.SendWinMsg(DataStructure: TCopyDataStruct);
var
  RecipientHandle: THandle;
  // Res: integer;
begin
  // ReceiverHandle := FindWindow(PChar('TReceiverMainForm'), PChar('ReceiverMainForm'));
  // ReceiverHandle := FindWindow(PChar('TMainFrm'), PChar('MainFrm'));
  RecipientHandle := FindWindow(nil, PChar('RC Shell'));

  { TODO: Have to handle this situation differently if it occurs whilst trying
    to dock into host app }
  // if RecipientHandle = 0 then
  // begin
  // Exit;
  // end;

  { Res := }
  SendMessage(RecipientHandle, WM_COPYDATA, Integer(Handle), Integer(@DataStructure));
end;

procedure TBaseFrm.SendString(S: string);
var
  DataStructure: TCopyDataStruct;
begin
  DataStructure.dwData := 0;
  // Integer(cdtString); //use it to identify the message contents
  DataStructure.cbData := (1 + Length(S)) * SizeOf(Char);
  DataStructure.lpData := PAnsiChar(S);
  SendWinMsg(DataStructure);
end;

procedure TBaseFrm.VerifyFolderStructure(RootDataFolder: string);
begin
//  TDirectory.CreateDirectory(RUtils.AddChar(JclSysInfo.GetProgramFilesFolder, '\', rpEnd) + RC_APP_FOLDER);
//  UserDataFolder := RUtils.AddChar(RUtils.GetShellFolderName(CSIDL_COMMON_DOCUMENTS), '\', rpEnd);
  TDirectory.CreateDirectory(RootDataFolder);

  TDirectory.CreateDirectory(RootDataFolder + COMMON_FOLDER);
  TDirectory.CreateDirectory(RootDataFolder + VB_SHELL_FOLDER);
end;

function TBaseFrm.ItemExists(SQLQuery: string): string;
begin
//
end;

//function TBaseFrm.GetShellResource: TShellResource;
//var
//  RegKey: TRegistry;
////  SL: TStringList;
//begin
////  RegKey := TRegistry.Create(KEY_ALL_ACCESS or KEY_WRITE or KEY_WOW64_64KEY);
////  SL := RUtils.CreateStringList(SL, COMMA);
//  TDirectory.CreateDirectory('C:\Data');
//  RegKey := TRegistry.Create(KEY_ALL_ACCESS or KEY_WRITE or KEY_WOW64_64KEY);
//  try
//    RegKey.RootKey := HKEY_CURRENT_USER;
//    RegKey.OpenKey(KEY_COMMON_RESOURCE, True);
//    Result.RootFolder := {RUtils.AddChar(RUtils.GetShellFolderName(CSIDL_COMMON_DOCUMENTS), '\', rpEnd) + }ROOT_DATA_FOLDER;
////    Result.RootFolder := RUtils.AddChar(RUtils.GetShellFolderName(CSIDL_COMMON_DOCUMENTS), '\', rpEnd) + ROOT_DATA_FOLDER;
////    SL.Add(FormatDateTime('dd/MM/yyyy hh:mm:ss', Now) + 'Before writing Root Folder value to registry');
////    SL.SaveToFile('C:\Data\RegLog.txt');
//
//    try
//      RegKey.WriteString('Root Folder', Result.RootFolder);
//    except
//      on E: Exception do
//      begin
////        SL.Add(FormatDateTime('dd/MM/yyyy hh:mm:ss', Now) + 'Exception: ' + E.Message);
////        SL.SaveToFile('C:\Data\RegLog.txt');
//      end;
//    end;
//
////    SL.Add(FormatDateTime('dd/MM/yyyy hh:mm:ss', Now) + 'After successfully writing Root Folder value to registry');
////    SL.SaveToFile('C:\Data\RegLog.txt');
//
//    if not RegKey.ValueExists('RC Shell Resource Files') then
//      RegKey.WriteString('RC Shell Resource Files', '\\RDI-DBN-FS\Apps\RC Shell\');
//
//    Result.ShellResourceFileFolder := RegKey.ReadString('RC Shell Resource Files');
//
//    RegKey.CloseKey;
//    RegKey.OpenKey(KEY_COMMON_DATABASE, True);
//    Result.ConnectionDefinitionFileLocation := RegKey.ReadString('Connection Definition File Location');
//    Result.ConnectionDefinitionFileName := RegKey.ReadString('Connection Definition File Name');
//
//    RegKey.CloseKey;
//    RegKey.OpenKey(KEY_COMMON_USER_PREFERENCES, True);
//
//    if not RegKey.ValueExists('Skin Name') then
//      RegKey.WriteString('Skin Name', DEFAULT_SKIN_NAME);
//
//    Result.SkinName := RegKey.ReadString('Skin Name');
//    RegKey.CloseKey;
//  finally
//    RegKey.Free;
//  end;
//end;

function TBaseFrm.GetUserData: TUserData;
var
  RegKey: TRegistry;
begin
  RegKey := TRegistry.Create(KEY_ALL_ACCESS or KEY_WRITE or KEY_WOW64_64KEY);
  try
    RegKey.RootKey := HKEY_CURRENT_USER;

    RegKey.OpenKey(KEY_USER_DATA, True);
    Result.UserName := RegKey.ReadString('User Name');
    Result.EmployeeName := RegKey.ReadString('Employee Name');
    Result.EmployeeNo := RegKey.ReadString('Employee No');
    Result.EmployeeID := RegKey.ReadInteger('Employee ID');
    Result.Department := RegKey.ReadString('Department');
    Result.ComputerName := RUtils.GetComputer;
    Result.IPAddress := RUtils.GetIPAddress(RUtils.GetComputer);
  finally
    RegKey.Free;
  end;
end;

function TBaseFrm.UpdateHistoryList(ListView: TcxListView; Item, ItemDesc: string): TcxListView;
var
  I: Integer;
  FoundItem: Boolean;
  LocalListView: TcxListView;
  AnItem: TListItem;
begin
  LocalListView := TcxListView.Create(nil);
  LocalListView := ListView;
  Result := LocalListView;

  if Length(Trim(Item)) = 0 then
    Exit;

  FoundItem := False;

  for I := 0 to Result.Items.Count - 1 do
  begin
    FoundItem := Item = Result.Items[I].Caption;
    if FoundItem then
      Break;
  end;

  if not FoundItem then
  begin
    AnItem := Result.Items.Add;
    AnItem.Caption := Item;
    AnItem.SubItems.Add(ItemDesc);
  end;
  Result := LocalListView;
end;

procedure TBaseFrm.CopyCellValue(AView: TcxCustomGridView);
var
  C: TcxCustomGridTableController;
begin
  C := TcxGridTableView(AView).Controller;
  Clipboard.Clear;
  Clipboard.AsText := C.FocusedRecord.Values[C.FocusedItem.Index];
end;

procedure TBaseFrm.DoCopyCellContent(Sender: TObject);
begin
  CopyCellValue(FView);
end;

//procedure TBaseFrm.SetActionStatus(Action: TActionArray);
//var
//  I, CountVisible: Integer;
//  A: array of Integer;
//begin
//  // Keep track of how many actions are visible in the current context.
//  CountVisible := 0;
//  // Set action visibility.
//  for I := 1 to actSendToList.ActionCount - 1 do
//  begin
//    actSendToList[I].Visible := Action[I];
//    if actSendToList[I].Visible then
//      Inc(CountVisible);
//  end;
//  // Display the separator only if there are any visible actions apart from the
//  // 'Copy cell content' action.
//  mnuSeparator1.Visible := CountVisible > 0;
//end;

end.

